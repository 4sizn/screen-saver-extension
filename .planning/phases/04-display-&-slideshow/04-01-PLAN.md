---
phase: 04-display-&-slideshow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - entrypoints/content/ScreenSaverOverlay.tsx
  - entrypoints/content/style.css
autonomous: true

must_haves:
  truths:
    - "Screen saver displays one randomly selected image when activated"
    - "Image displays with user-configured fit mode (cover or contain)"
    - "Background color shows correctly for images that don't fill screen"
    - "Only enabled images appear in rotation"
    - "If no enabled images exist, default images always display"
  artifacts:
    - path: "entrypoints/content/ScreenSaverOverlay.tsx"
      provides: "Image display component with loading states"
      min_lines: 80
      exports: ["default function ScreenSaverOverlay"]
    - path: "entrypoints/content/style.css"
      provides: "Image rendering styles with object-fit"
      contains: "object-fit"
  key_links:
    - from: "entrypoints/content/ScreenSaverOverlay.tsx"
      to: "lib/imageStorage.getAllImages()"
      via: "useEffect async load on mount"
      pattern: "getAllImages\\(\\)"
    - from: "entrypoints/content/ScreenSaverOverlay.tsx"
      to: "lib/settingsStorage.displaySettings.getValue()"
      via: "useEffect async load on mount"
      pattern: "displaySettings\\.getValue\\(\\)"
    - from: "ScreenSaverOverlay.tsx"
      to: "URL.createObjectURL(blob)"
      via: "blob URL generation for img src"
      pattern: "URL\\.createObjectURL"
    - from: "ScreenSaverOverlay.tsx"
      to: "URL.revokeObjectURL(url)"
      via: "useEffect cleanup return"
      pattern: "URL\\.revokeObjectURL"
---

<objective>
Replace placeholder screen saver content with real image display that reads from IndexedDB and user settings, rendering a randomly selected enabled image with proper fit mode and background color.

Purpose: Delivers core Phase 4 functionality - visual screen saver display with user customization

Output: ScreenSaverOverlay.tsx displays random enabled images with correct styling based on user preferences
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-display-&-slideshow/04-CONTEXT.md
@.planning/phases/04-display-&-slideshow/04-RESEARCH.md

## Prior Phase Context
@.planning/phases/01-foundation-&-activation/01-02-SUMMARY.md
@.planning/phases/02-content-storage/02-01-SUMMARY.md
@.planning/phases/03-settings-infrastructure/03-01-SUMMARY.md

## Existing Implementation
@entrypoints/content/ScreenSaverOverlay.tsx
@entrypoints/content/style.css
@lib/imageStorage.ts
@lib/settingsStorage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement image loading and selection logic</name>
  <files>entrypoints/content/ScreenSaverOverlay.tsx</files>
  <action>
Add async image loading logic to ScreenSaverOverlay component:

1. **State management:**
   - Add imageState: 'loading' | 'loaded' | 'error'
   - Add imageSrc: string | null (blob URL)
   - Add settings: { imageFit, backgroundColor } from DisplaySettings interface

2. **useEffect for loading (runs on mount):**
   - Use Promise.all() to load settings and images in parallel
   - Load displaySettings via `displaySettings.getValue()` from lib/settingsStorage
   - Load all images via `getAllImages()` from lib/imageStorage
   - Filter images to isEnabled: true only
   - If no enabled images, fall back to filtering isDefault: true (always enabled)
   - Select random image: `enabledImages[Math.floor(Math.random() * enabledImages.length)]`
   - Create blob URL: `URL.createObjectURL(selectedImage.blob)`
   - Set imageSrc state with blob URL
   - If any error occurs, set imageState to 'error'

3. **Cleanup function:**
   - Return cleanup function from useEffect
   - Revoke blob URL: `if (imageSrc) URL.revokeObjectURL(imageSrc);`
   - Critical: Prevents memory leak from orphaned blob URLs

4. **Why this approach:**
   - Parallel loading (Promise.all) reduces mount time
   - Random selection on mount provides fresh image each activation
   - Default fallback ensures display never fails
   - Blob URL cleanup prevents memory accumulation

**Import additions:**
```typescript
import { useState } from 'react'; // Add useState to existing useEffect import
import { getAllImages } from '@/lib/imageStorage';
import { displaySettings } from '@/lib/settingsStorage';
```
  </action>
  <verify>
```bash
# TypeScript compilation passes
npm run build

# Check for correct imports and state management
grep -E "(useState|getAllImages|displaySettings)" entrypoints/content/ScreenSaverOverlay.tsx

# Verify blob URL lifecycle management
grep -E "(createObjectURL|revokeObjectURL)" entrypoints/content/ScreenSaverOverlay.tsx
```
  </verify>
  <done>
ScreenSaverOverlay.tsx contains:
- useState for imageState, imageSrc, settings
- useEffect loading settings and images in parallel
- Random selection from enabled images with default fallback
- Blob URL creation and cleanup in useEffect return
- Error handling setting imageState to 'error'
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement image rendering UI with loading states</name>
  <files>entrypoints/content/ScreenSaverOverlay.tsx, entrypoints/content/style.css</files>
  <action>
Replace placeholder content in ScreenSaverOverlay return statement:

1. **Container structure:**
   - Root div with fixed positioning, inset-0, full viewport coverage
   - Apply backgroundColor from settings as inline style
   - className: "image-container" for CSS targeting

2. **Loading state (imageState === 'loading'):**
   - Centered flex container
   - Simple text: "Loading..." with white color
   - No spinner animation needed (loads fast)

3. **Error state (imageState === 'error'):**
   - Centered flex container
   - Text: "Unable to load image" with white color
   - Subtitle: "Check settings to enable images" with white/70 opacity

4. **Image element:**
   - src={imageSrc || ''}
   - alt="Screen saver"
   - className: full width/height, transition-opacity duration-300
   - Conditional opacity: 'opacity-100' when loaded, 'opacity-0' otherwise
   - Inline style: objectFit from settings.imageFit (cover or contain)
   - onLoad handler: () => setImageState('loaded')
   - onError handler: () => setImageState('error')

5. **CSS additions (style.css):**
```css
.image-container {
  position: fixed;
  inset: 0;
  width: 100vw;
  height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
}

.screen-saver-image {
  width: 100%;
  height: 100%;
  object-position: center;
}
```

6. **Why this approach:**
   - Inline backgroundColor style allows dynamic user customization
   - object-fit via inline style (not className) because it's user-configurable
   - Opacity transition provides smooth fade-in without flicker
   - onLoad/onError handlers manage state transitions automatically
   - Fixed positioning with inset-0 provides full-screen coverage (established in Phase 1)

**Preserve existing ESC key handler** - keep useEffect with keydown listener unchanged
  </action>
  <verify>
```bash
# Build passes
npm run build

# Verify image element with event handlers
grep -E "(onLoad|onError)" entrypoints/content/ScreenSaverOverlay.tsx

# Check CSS structure
grep -E "image-container" entrypoints/content/style.css

# Confirm ESC handler preserved
grep -E "Escape" entrypoints/content/ScreenSaverOverlay.tsx
```
  </verify>
  <done>
ScreenSaverOverlay.tsx renders:
- Container div with backgroundColor inline style
- Loading state with centered "Loading..." text
- Error state with centered error message
- Image element with objectFit inline style, opacity transition, onLoad/onError handlers
- ESC key handler preserved and unchanged

style.css contains:
- .image-container with fixed positioning and full viewport coverage
- .screen-saver-image with 100% dimensions and centered object-position
  </done>
</task>

</tasks>

<verification>
After implementation:

1. **TypeScript compilation:**
```bash
npm run build
```
Should pass without errors.

2. **Code structure checks:**
```bash
# Verify blob URL lifecycle
grep -E "(createObjectURL|revokeObjectURL)" entrypoints/content/ScreenSaverOverlay.tsx

# Verify state management
grep -E "useState.*imageState|imageSrc|settings" entrypoints/content/ScreenSaverOverlay.tsx

# Verify imports
grep -E "import.*getAllImages|displaySettings" entrypoints/content/ScreenSaverOverlay.tsx
```

3. **Ready for Plan 04-02 visual verification:**
Plan 04-02 will perform human verification of actual display with various fit modes, colors, and image types.
</verification>

<success_criteria>
Plan complete when:
- [ ] ScreenSaverOverlay.tsx loads settings and images on mount
- [ ] Random enabled image selected with default fallback logic
- [ ] Blob URL created and stored in state
- [ ] Image element renders with dynamic objectFit and backgroundColor
- [ ] Loading and error states display appropriately
- [ ] onLoad/onError handlers manage state transitions
- [ ] Blob URL cleanup in useEffect return prevents memory leak
- [ ] ESC key handler preserved
- [ ] TypeScript compilation passes
- [ ] CSS provides full-screen container and image styling
</success_criteria>

<output>
After completion, create `.planning/phases/04-display-&-slideshow/04-01-SUMMARY.md`
</output>
