---
phase: 02-content-storage
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - public/images/defaults/*.jpg
  - lib/defaultImages.ts
  - entrypoints/options/index.html
  - entrypoints/options/App.tsx
  - entrypoints/options/style.css
autonomous: true

must_haves:
  truths:
    - "Extension includes 10-20 default nature landscape images"
    - "Default images are bundled in public/images/defaults/ directory"
    - "Default images load into IndexedDB on first install"
    - "User can access options page from browser extension settings"
  artifacts:
    - path: "public/images/defaults/"
      provides: "10-20 default nature landscape images"
      contains: "*.jpg"
    - path: "lib/defaultImages.ts"
      provides: "Default image loading logic"
      exports: ["loadDefaultImages", "DEFAULT_IMAGES"]
      min_lines: 40
    - path: "entrypoints/options/index.html"
      provides: "Options page entry HTML"
      contains: "<div id=\"root\"></div>"
    - path: "entrypoints/options/App.tsx"
      provides: "Options page root React component"
      exports: ["default"]
      min_lines: 20
  key_links:
    - from: "lib/defaultImages.ts"
      to: "lib/imageStorage.ts"
      via: "saveImage import"
      pattern: "import.*saveImage.*from.*imageStorage"
    - from: "entrypoints/options/App.tsx"
      to: "React"
      via: "ReactDOM.createRoot"
      pattern: "ReactDOM\\.createRoot"
---

<objective>
Bundle default nature landscape images and create options page scaffold for image management UI.

Purpose: Provide immediate value (users don't need to upload images to use extension) and establish the settings page structure where users will manage their image collection.

Output: 10-20 default images bundled in public/, loading logic for first install, and WXT options page entrypoint with React scaffold.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-content-storage/02-RESEARCH.md

# Created in Wave 1
@.planning/phases/02-content-storage/02-01-PLAN.md

# Existing WXT structure from Phase 01
@entrypoints/background.ts
@entrypoints/content/index.tsx
</context>

<tasks>

<task type="checkpoint:decision" gate="blocking">
  <decision>How to source default nature landscape images</decision>
  <context>
Phase requires 15 default images bundled in public/images/defaults/. Two approaches:

**Option A (Automated):** Download from Unsplash using specific photo IDs
- Pros: Fully automated, reproducible, high-quality nature images
- Cons: Requires Unsplash photo IDs, licensing verification

**Option B (Manual):** Human manually downloads and places images
- Pros: Complete control over image selection
- Cons: Manual work, not automated

Given GSD's automation-first principle, Option A is preferred if specific photo IDs are provided.
  </context>
  <options>
    <option id="unsplash-auto">
      <name>Download from Unsplash with specific photo IDs (automated)</name>
      <pros>Fully automated, high-quality curated images, Unsplash License compatible</pros>
      <cons>Requires you to provide 15 specific Unsplash photo IDs/URLs</cons>
      <implementation>
Provide 15 Unsplash photo URLs in this format:
- https://unsplash.com/photos/{photo-id-1}
- https://unsplash.com/photos/{photo-id-2}
- ... (13 more)

Claude will:
1. Download each using Unsplash's URL format: ?w=1920&q=85
2. Convert to JPEG if needed
3. Optimize to <500KB using ImageMagick
4. Name as nature-01.jpg through nature-15.jpg
      </implementation>
    </option>
    <option id="manual-download">
      <name>Human manually downloads and places images</name>
      <pros>Complete control over image selection and quality</pros>
      <cons>Manual work, breaks automation flow</cons>
      <implementation>
Human will:
1. Search Unsplash for "nature landscape" images
2. Download 15 images (1920x1080, JPEG, <500KB each)
3. Rename to nature-01.jpg through nature-15.jpg
4. Place in public/images/defaults/ directory
5. Signal completion for Claude to continue with lib/defaultImages.ts
      </implementation>
    </option>
    <option id="placeholder-first">
      <name>Use placeholder images now, replace later</name>
      <pros>Unblocks development, can be improved later</pros>
      <cons>Placeholder quality, requires follow-up work</cons>
      <implementation>
Claude will:
1. Generate 15 solid color placeholder images using ImageMagick
2. Each 1920x1080 JPEG with gradient backgrounds
3. Labeled "Placeholder 1" through "Placeholder 15"
4. Continue with full automation
5. TODO added to replace with real images later
      </implementation>
    </option>
  </options>
  <resume-signal>
Select: "unsplash-auto" (with 15 photo URLs), "manual-download", or "placeholder-first"
  </resume-signal>
</task>

<task type="auto">
  <name>Task 1: Bundle default nature landscape images</name>
  <files>public/images/defaults/*.jpg, lib/defaultImages.ts</files>
  <action>
Create public/images/defaults/ directory and populate based on decision checkpoint:

**If unsplash-auto selected:**

Download 15 specific images from provided Unsplash photo URLs:

```bash
mkdir -p public/images/defaults

# For each provided Unsplash photo URL:
# https://unsplash.com/photos/{photo-id}
# Download with: https://images.unsplash.com/photo-{photo-id}?w=1920&q=85

# Example for photo-id "eOpewngf68w":
curl -o temp-01.jpg "https://images.unsplash.com/photo-eOpewngf68w?w=1920&q=85"

# Optimize if needed (ensure <500KB):
convert temp-01.jpg -resize 1920x1080^ -quality 85 -strip public/images/defaults/nature-01.jpg

# Repeat for all 15 images
```

**If manual-download selected:**

Wait for human to download and place 15 images in public/images/defaults/.

Verify images meet specs:
```bash
ls -lh public/images/defaults/*.jpg | wc -l  # Should be 15

# Check each is <500KB and 1920x1080
for f in public/images/defaults/*.jpg; do
  size=$(stat -f%z "$f")
  if [ $size -gt 524288 ]; then
    echo "ERROR: $f is larger than 500KB, needs optimization"
  fi
  # Check dimensions with ImageMagick identify
  identify -format "%wx%h\n" "$f"
done
```

**If placeholder-first selected:**

Generate 15 placeholder images with gradients:

```bash
mkdir -p public/images/defaults

for i in {1..15}; do
  # Generate gradient placeholder
  convert -size 1920x1080 \
    gradient:"#${i}A5D7E-#${i}3B5E7" \
    -quality 85 \
    -font Arial -pointsize 72 -fill white -gravity center \
    -annotate +0+0 "Placeholder $i" \
    public/images/defaults/nature-$(printf "%02d" $i).jpg
done
```

Add TODO comment to README or STATE.md:
```
TODO: Replace placeholder images with real Unsplash nature images
```

**After images are in place, create lib/defaultImages.ts:**

```typescript
import { saveImage } from './imageStorage';
import { browser } from 'wxt/browser';

export const DEFAULT_IMAGES = [
  '/images/defaults/nature-01.jpg',
  '/images/defaults/nature-02.jpg',
  '/images/defaults/nature-03.jpg',
  '/images/defaults/nature-04.jpg',
  '/images/defaults/nature-05.jpg',
  '/images/defaults/nature-06.jpg',
  '/images/defaults/nature-07.jpg',
  '/images/defaults/nature-08.jpg',
  '/images/defaults/nature-09.jpg',
  '/images/defaults/nature-10.jpg',
  '/images/defaults/nature-11.jpg',
  '/images/defaults/nature-12.jpg',
  '/images/defaults/nature-13.jpg',
  '/images/defaults/nature-14.jpg',
  '/images/defaults/nature-15.jpg',
];

export async function loadDefaultImages() {
  const { openDB } = await import('idb');
  const db = await openDB('screen-saver-images', 1);
  const count = await db.count('images');

  // Only load if database is empty (first install)
  if (count > 0) {
    console.log('Default images already loaded, skipping');
    return;
  }

  console.log('Loading default images...');

  for (let i = 0; i < DEFAULT_IMAGES.length; i++) {
    const url = browser.runtime.getURL(DEFAULT_IMAGES[i]);

    try {
      const response = await fetch(url);
      const blob = await response.blob();

      await saveImage(
        `default-${i + 1}`,
        blob,
        `Default Nature ${i + 1}`,
        true // isDefault flag
      );

      console.log(`Loaded default image ${i + 1}/${DEFAULT_IMAGES.length}`);
    } catch (error) {
      console.error(`Failed to load default image ${i + 1}:`, error);
    }
  }

  console.log('Default images loaded successfully');
}
```

**Critical patterns:**
- Check database count BEFORE loading (avoid duplicates)
- Use browser.runtime.getURL for extension resource URLs
- Mark images with isDefault: true (prevents deletion)
- Sequential loading with error handling per image
- Log progress for debugging

**DO NOT:**
- Load defaults on every extension start (only first install)
- Use relative paths (use browser.runtime.getURL)
- Allow deletion of default images (enforced by isDefault flag)
  </action>
  <verify>
Check files exist:
```bash
ls -lh public/images/defaults/*.jpg | wc -l  # Should be 15
du -sh public/images/defaults  # Should be ~7-8MB (or <1MB for placeholders)
```

Check image sizes:
```bash
for f in public/images/defaults/*.jpg; do
  size=$(stat -f%z "$f")
  if [ $size -gt 524288 ]; then
    echo "WARNING: $f is larger than 500KB ($size bytes)"
  fi
done
```

Type check:
```bash
npm run type-check
```
  </verify>
  <done>
- public/images/defaults/ contains 15 JPEG files
- Each image is <500KB, 1920x1080 resolution (or placeholders documented)
- lib/defaultImages.ts exports DEFAULT_IMAGES and loadDefaultImages()
- Loading logic checks database count before loading
- TypeScript types working
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WXT options page entrypoint</name>
  <files>entrypoints/options/index.html, entrypoints/options/App.tsx, entrypoints/options/style.css</files>
  <action>
Create entrypoints/options/ directory with WXT options page structure:

**Create entrypoints/options/index.html:**
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Open in dedicated tab instead of inline modal -->
  <meta name="manifest.open_in_tab" content="true" />
  <title>Screen Saver Settings</title>
</head>
<body>
  <div id="root"></div>
  <script type="module" src="./App.tsx"></script>
</body>
</html>
```

**Key meta tag:** `manifest.open_in_tab` = true opens settings in full tab (not inline modal).

**Create entrypoints/options/App.tsx:**
```typescript
import React from 'react';
import ReactDOM from 'react-dom/client';
import './style.css';

function OptionsApp() {
  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="container mx-auto max-w-4xl px-4">
        <header className="mb-8">
          <h1 className="text-4xl font-bold text-gray-900">Screen Saver Settings</h1>
          <p className="mt-2 text-gray-600">
            Manage your image collection and customize your screen saver experience
          </p>
        </header>

        <main>
          <div className="rounded-lg bg-white p-6 shadow">
            <p className="text-gray-600">
              Image management components will be added in the next plan.
            </p>
          </div>
        </main>
      </div>
    </div>
  );
}

const root = document.getElementById('root');
if (root) {
  ReactDOM.createRoot(root).render(
    <React.StrictMode>
      <OptionsApp />
    </React.StrictMode>
  );
}

export default OptionsApp;
```

**Create entrypoints/options/style.css:**
```css
@import "tailwindcss";
```

This imports Tailwind v4 (already configured in Phase 01 postcss.config.js).

**WXT auto-detection:**
- WXT scans entrypoints/ directory
- Finds options/index.html
- Generates manifest options_page field automatically
- Users can access via: Right-click extension icon → Options

**DO NOT:**
- Manually configure manifest options_page (WXT auto-generates)
- Use popup instead of options (popup is for quick actions, options is for settings)
- Skip "manifest.open_in_tab" (inline modal is cramped for image management)
  </action>
  <verify>
Build extension to verify WXT recognizes options entrypoint:
```bash
npm run build
```

Check generated manifest includes options_page:
```bash
cat .output/chrome-mv3/manifest.json | grep -A2 options
```

Type check:
```bash
npm run type-check
```
  </verify>
  <done>
- entrypoints/options/index.html exists with root div and module script
- entrypoints/options/App.tsx exists with React root component
- entrypoints/options/style.css exists with Tailwind import
- WXT build generates options_page in manifest
- Options page accessible from extension settings
- No TypeScript errors
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. 15 default images exist in public/images/defaults/ (or decision checkpoint resolved)
2. lib/defaultImages.ts has loading logic with database check
3. Options page entrypoint exists and WXT recognizes it
4. Extension builds successfully with options_page in manifest
5. All images are <500KB and properly formatted
</verification>

<success_criteria>
- Default images bundled and ready for loading (CONT-01 fulfilled)
- Options page structure exists for Wave 3 UI components
- Extension can be opened from browser settings (right-click → Options)
- Foundation complete for image upload and management UI
</success_criteria>

<output>
After completion, create `.planning/phases/02-content-storage/02-03-SUMMARY.md` with:
- Default images sourced and bundled (count, total size, method used)
- Options page entrypoint created
- WXT auto-detection verified
- Any decisions about image selection or layout
</output>
