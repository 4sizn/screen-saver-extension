---
phase: 02-content-storage
plan: 04
type: execute
wave: 3
depends_on: ["02-01", "02-02", "02-03"]
files_modified:
  - entrypoints/options/components/ImageUpload.tsx
  - entrypoints/options/components/ImageList.tsx
  - entrypoints/options/App.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "User can upload custom images via file picker"
    - "Uploaded images are compressed to <500KB before storage"
    - "User can view list of all uploaded images with thumbnails"
    - "User can delete individual uploaded images"
    - "User can reorder images via drag-and-drop"
    - "Default images cannot be deleted"
    - "Default images are visually distinguished from uploaded images"
  artifacts:
    - path: "entrypoints/options/components/ImageUpload.tsx"
      provides: "File upload component with compression and validation"
      exports: ["default"]
      min_lines: 80
    - path: "entrypoints/options/components/ImageList.tsx"
      provides: "Sortable image list with delete and drag-and-drop"
      exports: ["default"]
      min_lines: 150
  key_links:
    - from: "entrypoints/options/components/ImageUpload.tsx"
      to: "lib/imageProcessing.ts"
      via: "compressImage, validateImageFile imports"
      pattern: "import.*compressImage.*from.*imageProcessing"
    - from: "entrypoints/options/components/ImageUpload.tsx"
      to: "lib/imageStorage.ts"
      via: "saveImage import"
      pattern: "import.*saveImage.*from.*imageStorage"
    - from: "entrypoints/options/components/ImageList.tsx"
      to: "@dnd-kit/core"
      via: "DndContext import"
      pattern: "import.*DndContext.*from.*@dnd-kit/core"
    - from: "entrypoints/options/components/ImageList.tsx"
      to: "lib/imageStorage.ts"
      via: "getAllImages, deleteImage, reorderImages imports"
      pattern: "import.*getAllImages.*from.*imageStorage"
    - from: "entrypoints/options/App.tsx"
      to: "components/ImageUpload.tsx"
      via: "ImageUpload component usage"
      pattern: "<ImageUpload"
    - from: "entrypoints/options/App.tsx"
      to: "components/ImageList.tsx"
      via: "ImageList component usage"
      pattern: "<ImageList"
---

<objective>
Build image upload and management UI components with file validation, compression, and drag-and-drop reordering.

Purpose: Enable users to upload custom images (fulfilling CONT-02), view their collection with visual thumbnails (CONT-04), delete images (CONT-05), and reorder via drag-and-drop (CONT-06).

Output: Two React components (ImageUpload, ImageList) integrated into options page, providing complete image management functionality.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-content-storage/02-RESEARCH.md

# Created in prior waves
@.planning/phases/02-content-storage/02-01-PLAN.md
@.planning/phases/02-content-storage/02-02-PLAN.md
@.planning/phases/02-content-storage/02-03-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create image upload component with compression</name>
  <files>entrypoints/options/components/ImageUpload.tsx</files>
  <action>
Create entrypoints/options/components/ directory and ImageUpload.tsx component:

**Component functionality:**
1. File input with accept="image/jpeg,image/jpg,image/png,image/webp"
2. Client-side validation (type, size <10MB)
3. Image compression to <500KB using browser-image-compression
4. Preview before upload
5. Progress indicator during compression
6. Save to IndexedDB with UUID
7. Success/error feedback
8. Object URL cleanup to prevent memory leaks

**Implementation structure:**
```typescript
import React, { useState } from 'react';
import { compressImage, validateImageFile } from '@/lib/imageProcessing';
import { saveImage } from '@/lib/imageStorage';
import { Button } from '@/components/ui/button';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';

export default function ImageUpload() {
  const [uploading, setUploading] = useState(false);
  const [preview, setPreview] = useState<string | null>(null);
  const [progress, setProgress] = useState(0);

  async function handleFileChange(e: React.ChangeEvent<HTMLInputElement>) {
    const file = e.target.files?.[0];
    if (!file) return;

    // Validate file
    const validation = validateImageFile(file);
    if (!validation.valid) {
      alert(validation.error);
      return;
    }

    setUploading(true);
    setProgress(0);

    try {
      // Show preview
      const previewUrl = URL.createObjectURL(file);
      setPreview(previewUrl);

      // Compress image with progress callback
      const compressedBlob = await compressImage(file);

      // Save to IndexedDB
      const id = crypto.randomUUID();
      await saveImage(id, compressedBlob, file.name);

      // Show success with size comparison
      alert(
        `Image uploaded! Original: ${(file.size / 1024 / 1024).toFixed(2)}MB, Compressed: ${(compressedBlob.size / 1024 / 1024).toFixed(2)}MB`
      );

      // Clean up
      URL.revokeObjectURL(previewUrl);
      setPreview(null);
      setProgress(0);
      e.target.value = ''; // Reset input

      // Trigger parent refresh (event or callback)
      window.dispatchEvent(new CustomEvent('image-uploaded'));
    } catch (error) {
      console.error('Upload failed:', error);
      alert('Failed to upload image. Please try again.');
    } finally {
      setUploading(false);
    }
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Upload Custom Images</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center">
          <input
            type="file"
            id="image-upload"
            accept="image/jpeg,image/jpg,image/png,image/webp"
            onChange={handleFileChange}
            disabled={uploading}
            className="hidden"
          />
          <label htmlFor="image-upload" className="cursor-pointer">
            <Button disabled={uploading} asChild>
              <span>
                {uploading ? `Compressing... ${progress}%` : 'Choose Image'}
              </span>
            </Button>
          </label>

          {preview && (
            <div className="mt-4">
              <img
                src={preview}
                alt="Preview"
                className="max-w-md mx-auto rounded-lg shadow-lg"
              />
            </div>
          )}

          <p className="mt-4 text-sm text-gray-500">
            Supported: JPEG, PNG, WebP (max 10MB)
            <br />
            Images optimized to 1920x1080, ~500KB
          </p>
        </div>
      </CardContent>
    </Card>
  );
}
```

**Critical patterns:**
- Use hidden input + label for custom button styling
- Call URL.revokeObjectURL to prevent memory leaks
- Reset input value after upload (allows re-upload same file)
- Dispatch custom event for parent refresh
- Show compression progress and size comparison

**DO NOT:**
- Skip validation (security risk)
- Forget to revoke object URLs (memory leak)
- Block UI during compression (use Web Worker via library)
  </action>
  <verify>
Type check:
```bash
npm run type-check
```

Build to verify imports resolve:
```bash
npm run build
```
  </verify>
  <done>
- entrypoints/options/components/ImageUpload.tsx exists with 80+ lines
- Uses compressImage and validateImageFile from lib/imageProcessing.ts
- Uses saveImage from lib/imageStorage.ts
- Uses Button and Card from Shadcn UI
- File validation, compression, preview, and IndexedDB save implemented
- Object URL cleanup in place
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sortable image list with delete and drag-and-drop</name>
  <files>entrypoints/options/components/ImageList.tsx, entrypoints/options/App.tsx, package.json</files>
  <action>
Install @dnd-kit for drag-and-drop reordering:
```bash
npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```

Create entrypoints/options/components/ImageList.tsx:

**Component functionality:**
1. Load all images from IndexedDB on mount
2. Display as sortable vertical list with thumbnails
3. Drag-and-drop reordering with visual feedback
4. Delete button for custom images (disabled for defaults)
5. Drag handle icon for clear affordance
6. Keyboard navigation support (arrow keys)
7. Object URL management with cleanup
8. Re-fetch on image-uploaded event
9. **Visual indicator for default images (NOT just text label)**

**Visual indicator specification:**
Default images must have a VISUAL badge/icon/border to distinguish them at a glance:

- **Badge approach (PREFERRED):** Blue "DEFAULT" badge overlaid on top-left corner of thumbnail
- **Icon approach (ALTERNATIVE):** Shield or lock icon next to image name
- **Border approach (ALTERNATIVE):** Distinct blue border around thumbnail

DO NOT rely only on text label "Default image" - user should be able to identify defaults visually without reading text.

**Implementation structure:**
```typescript
import React, { useEffect, useState } from 'react';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core';
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
  useSortable,
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { getAllImages, deleteImage, reorderImages } from '@/lib/imageStorage';
import { Button } from '@/components/ui/button';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';

interface ImageItem {
  id: string;
  blob: Blob;
  name: string;
  order: number;
  isDefault: boolean;
}

function SortableImage({
  item,
  onDelete,
}: {
  item: ImageItem;
  onDelete: (id: string) => void;
}) {
  const { attributes, listeners, setNodeRef, transform, transition } =
    useSortable({ id: item.id });

  const [objectUrl, setObjectUrl] = useState<string>('');

  useEffect(() => {
    const url = URL.createObjectURL(item.blob);
    setObjectUrl(url);
    return () => URL.revokeObjectURL(url);
  }, [item.blob]);

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className="flex items-center gap-4 rounded-lg border bg-white p-4 mb-2 shadow-sm"
    >
      <div
        {...attributes}
        {...listeners}
        className="cursor-grab active:cursor-grabbing text-gray-400 hover:text-gray-600"
      >
        {/* Drag handle icon */}
        <svg className="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
          <path d="M9 3h2v2H9V3zm0 4h2v2H9V7zm0 4h2v2H9v-2zm0 4h2v2H9v-2zm0 4h2v2H9v-2zm4-16h2v2h-2V3zm0 4h2v2h-2V7zm0 4h2v2h-2v-2zm0 4h2v2h-2v-2zm0 4h2v2h-2v-2z" />
        </svg>
      </div>

      <div className="relative">
        <img
          src={objectUrl}
          alt={item.name}
          className={`w-20 h-20 object-cover rounded ${
            item.isDefault ? 'ring-2 ring-blue-500' : ''
          }`}
        />
        {/* VISUAL INDICATOR: Badge overlay for default images */}
        {item.isDefault && (
          <div className="absolute top-0 left-0 bg-blue-600 text-white text-xs font-bold px-2 py-1 rounded-br">
            DEFAULT
          </div>
        )}
      </div>

      <div className="flex-1">
        <p className="font-medium text-gray-900">{item.name}</p>
        {item.isDefault && (
          <div className="flex items-center gap-1 mt-1">
            {/* Shield icon for additional visual cue */}
            <svg className="w-4 h-4 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M10 1.944A11.954 11.954 0 012.166 5C2.056 5.649 2 6.319 2 7c0 5.225 3.34 9.67 8 11.317C14.66 16.67 18 12.225 18 7c0-.682-.057-1.35-.166-2.001A11.954 11.954 0 0110 1.944zM11 14a1 1 0 11-2 0 1 1 0 012 0zm0-7a1 1 0 10-2 0v3a1 1 0 102 0V7z" clipRule="evenodd" />
            </svg>
            <span className="text-xs text-blue-600">Bundled image</span>
          </div>
        )}
      </div>

      {!item.isDefault && (
        <Button
          variant="destructive"
          size="sm"
          onClick={() => onDelete(item.id)}
        >
          Delete
        </Button>
      )}
    </div>
  );
}

export default function ImageList() {
  const [items, setItems] = useState<ImageItem[]>([]);

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  useEffect(() => {
    loadImages();

    // Refresh on upload
    const handleUpload = () => loadImages();
    window.addEventListener('image-uploaded', handleUpload);
    return () => window.removeEventListener('image-uploaded', handleUpload);
  }, []);

  async function loadImages() {
    const images = await getAllImages();
    setItems(images);
  }

  async function handleDragEnd(event: DragEndEvent) {
    const { active, over } = event;

    if (over && active.id !== over.id) {
      setItems((items) => {
        const oldIndex = items.findIndex((i) => i.id === active.id);
        const newIndex = items.findIndex((i) => i.id === over.id);
        const newItems = arrayMove(items, oldIndex, newIndex);

        // Persist new order to IndexedDB
        reorderImages(newItems.map((i) => i.id));

        return newItems;
      });
    }
  }

  async function handleDelete(id: string) {
    if (confirm('Delete this image?')) {
      try {
        await deleteImage(id);
        await loadImages();
      } catch (error) {
        alert('Cannot delete default images');
      }
    }
  }

  return (
    <Card className="mt-8">
      <CardHeader>
        <CardTitle>Your Images ({items.length})</CardTitle>
      </CardHeader>
      <CardContent>
        {items.length === 0 ? (
          <p className="text-gray-500 text-center py-8">
            No images yet. Upload your first image above!
          </p>
        ) : (
          <DndContext
            sensors={sensors}
            collisionDetection={closestCenter}
            onDragEnd={handleDragEnd}
          >
            <SortableContext
              items={items.map((i) => i.id)}
              strategy={verticalListSortingStrategy}
            >
              {items.map((item) => (
                <SortableImage
                  key={item.id}
                  item={item}
                  onDelete={handleDelete}
                />
              ))}
            </SortableContext>
          </DndContext>
        )}
      </CardContent>
    </Card>
  );
}
```

**Update entrypoints/options/App.tsx to integrate components:**
```typescript
import ImageUpload from './components/ImageUpload';
import ImageList from './components/ImageList';

// In OptionsApp return:
<main>
  <ImageUpload />
  <ImageList />
</main>
```

**Critical patterns:**
- Use sensors for mouse and keyboard support
- arrayMove from @dnd-kit/sortable for reordering
- Persist order immediately via reorderImages()
- Prevent deletion of default images (isDefault check)
- Object URL cleanup in SortableImage useEffect
- Refresh list on custom 'image-uploaded' event
- **VISUAL badge/border/icon for default images** (not just text)

**DO NOT:**
- Skip keyboard sensor (accessibility issue)
- Allow deletion of default images
- Forget object URL cleanup (memory leak)
- Mutate items array directly (use arrayMove)
- Rely only on text label for default images (needs visual indicator)
  </action>
  <verify>
Type check:
```bash
npm run type-check
```

Build extension:
```bash
npm run build
```

Check dnd-kit installed:
```bash
npm list @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```
  </verify>
  <done>
- entrypoints/options/components/ImageList.tsx exists with 150+ lines
- Uses @dnd-kit for drag-and-drop reordering
- Uses getAllImages, deleteImage, reorderImages from lib/imageStorage.ts
- SortableImage subcomponent with drag handle and delete button
- Default images have VISUAL indicator (badge overlay + ring border + icon)
- Keyboard navigation support enabled
- Object URL cleanup implemented
- ImageUpload and ImageList integrated into App.tsx
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
After completing both tasks:
1. ImageUpload component exists with file validation and compression
2. ImageList component exists with drag-and-drop and delete
3. Default images have visible badge/border/icon (not just text)
4. Both components integrated into options page App.tsx
5. @dnd-kit dependencies installed
6. Type checking passes
7. Extension builds successfully
</verification>

<success_criteria>
- User can upload images via file picker (CONT-02 fulfilled)
- Images compressed to <500KB before storage (CONT-03 enhanced)
- User can view list of all images (CONT-04 fulfilled)
- User can delete custom images (CONT-05 fulfilled)
- User can reorder images via drag-and-drop (CONT-06 fulfilled)
- Default images protected from deletion
- Default images visually distinguished with badge/border/icon
</success_criteria>

<output>
After completion, create `.planning/phases/02-content-storage/02-04-SUMMARY.md` with:
- Components created (ImageUpload, ImageList)
- Tech added (@dnd-kit libraries)
- Visual indicator approach chosen for default images
- Patterns established (drag-and-drop, object URL management, event-based refresh)
- Any implementation decisions made
</output>
