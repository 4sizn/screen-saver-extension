---
phase: 01-foundation-&-activation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - entrypoints/content/index.tsx
  - entrypoints/content/ScreenSaverOverlay.tsx
  - entrypoints/content/style.css
autonomous: true

must_haves:
  truths:
    - "Full-screen overlay appears when activation message received from background"
    - "Overlay covers entire viewport with maximum z-index, isolated from page styles"
    - "ESC key press sends deactivate message to background script"
    - "Overlay unmounts cleanly when deactivation message received"
  artifacts:
    - path: "entrypoints/content/index.tsx"
      provides: "Content script with Shadow DOM UI lifecycle"
      exports: ["defineContentScript"]
      min_lines: 40
    - path: "entrypoints/content/ScreenSaverOverlay.tsx"
      provides: "React component for full-screen overlay with ESC handler"
      exports: ["default"]
      min_lines: 30
    - path: "entrypoints/content/style.css"
      provides: "Fixed positioning styles for full-screen overlay"
      min_lines: 15
  key_links:
    - from: "entrypoints/content/index.tsx"
      to: "browser.runtime.onMessage"
      via: "message listener for ACTIVATE/DEACTIVATE"
      pattern: "runtime\\.onMessage\\.addListener"
    - from: "entrypoints/content/index.tsx"
      to: "ui.mount() and ui.remove()"
      via: "Shadow DOM UI lifecycle control"
      pattern: "ui\\.(mount|remove)\\(\\)"
    - from: "entrypoints/content/ScreenSaverOverlay.tsx"
      to: "window.addEventListener('keydown')"
      via: "ESC key detection"
      pattern: "key === 'Escape'"
    - from: "entrypoints/content/ScreenSaverOverlay.tsx"
      to: "browser.runtime.sendMessage"
      via: "sends DEACTIVATE on ESC press"
      pattern: "sendMessage.*DEACTIVATE"
---

<objective>
Implement the content script that injects a full-screen React overlay using WXT's Shadow DOM UI system. The overlay responds to activation/deactivation messages from the background script and handles ESC key presses for user-initiated deactivation.

Purpose: Create the visual layer that displays when the screen saver activates, with proper style isolation from host pages and reliable keyboard event handling.

Output: Content script that mounts/unmounts a full-screen overlay in response to messages, with ESC key deactivation working across all websites.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-&-activation/01-CONTEXT.md
@.planning/phases/01-foundation-&-activation/01-RESEARCH.md
@.planning/phases/01-foundation-&-activation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create content script with Shadow DOM UI lifecycle</name>
  <files>
    entrypoints/content/index.tsx
  </files>
  <action>
Create the content script that injects a Shadow DOM-based React overlay into all web pages, listening for ACTIVATE/DEACTIVATE messages from the background script.

**Create entrypoints/content/index.tsx:**

Follow RESEARCH.md "Complete Content Script with Shadow DOM" pattern with these specifications:

1. **Imports:**
   - Import './style.css' (WXT auto-injects into Shadow DOM)
   - Import ReactDOM from 'react-dom/client'
   - Import ScreenSaverOverlay component (to be created in Task 2)
   - Import browser from 'wxt/browser'
   - Import message types from lib/messages

2. **defineContentScript configuration:**
   - matches: ['<all_urls>'] (inject into all pages)
   - cssInjectionMode: 'ui' (inject CSS into Shadow DOM, not page)

3. **Shadow DOM UI creation:**
   - Use createShadowRootUi with name 'screen-saver-overlay'
   - position: 'overlay' (WXT handles fixed positioning)
   - anchor: 'body' (attach to document.body)
   - onMount: Create ReactDOM root and render ScreenSaverOverlay
   - onRemove: Unmount React root cleanly

4. **Message listener:**
   - Listen to browser.runtime.onMessage
   - On ACTIVATE message: call ui.mount()
   - On DEACTIVATE message: call ui.remove()
   - Store ui reference outside listener scope for access

**CRITICAL from RESEARCH.md:**
- cssInjectionMode: 'ui' ensures styles go into Shadow DOM, not host page
- Shadow DOM provides style isolation (prevents page CSS from affecting overlay)
- WXT handles Shadow DOM creation, focus management, and cleanup

**Why Shadow DOM:**
- Style isolation: Page CSS cannot interfere with extension UI
- Security: Page JavaScript cannot access Shadow DOM internals
- Consistency: Overlay looks identical across all websites

**Why NOT Fullscreen API (from RESEARCH.md Pitfall 1):**
- requestFullscreen() requires user interaction (transient activation)
- Programmatic activation from icon click will fail
- Use CSS fixed positioning instead
  </action>
  <verify>
```bash
# Check file exists
ls entrypoints/content/index.tsx

# Verify content script registered correctly
npm run build
ls .output/chrome-mv3/content-scripts/content.js

# Check for required patterns
grep "defineContentScript" entrypoints/content/index.tsx
grep "createShadowRootUi" entrypoints/content/index.tsx
grep "cssInjectionMode.*ui" entrypoints/content/index.tsx
grep "runtime.onMessage" entrypoints/content/index.tsx
grep "ui.mount" entrypoints/content/index.tsx
grep "ui.remove" entrypoints/content/index.tsx
```
  </verify>
  <done>
- entrypoints/content/index.tsx exists with defineContentScript export
- Content script matches <all_urls> pattern
- cssInjectionMode set to 'ui' for Shadow DOM style injection
- Shadow DOM UI created with createShadowRootUi
- Message listener handles ACTIVATE (ui.mount) and DEACTIVATE (ui.remove)
- React root created in onMount, unmounted in onRemove
- Build generates content-scripts/content.js without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Build full-screen overlay component with ESC key handler</name>
  <files>
    entrypoints/content/ScreenSaverOverlay.tsx
    entrypoints/content/style.css
  </files>
  <action>
Create the React component that renders the full-screen overlay and handles ESC key presses to deactivate the screen saver.

**Create entrypoints/content/ScreenSaverOverlay.tsx:**

Follow RESEARCH.md "Overlay Component with ESC Handler" pattern:

1. **Imports:**
   - Import useEffect from 'react'
   - Import browser from 'wxt/browser'

2. **ESC key handler (useEffect):**
   - Add keydown event listener to window (not overlay element - ensures capture even if focus changes)
   - Check if e.key === 'Escape'
   - Send DEACTIVATE message via browser.runtime.sendMessage({ type: 'DEACTIVATE' })
   - Clean up listener on unmount (return cleanup function)

3. **Render:**
   - Single container div with className "overlay-container"
   - Placeholder content showing "Screen Saver Active" and "Press ESC to exit"
   - Use Tailwind classes for text styling (text-white, text-2xl, etc.)
   - Keep simple - actual image display happens in Phase 4

**Create entrypoints/content/style.css:**

Follow RESEARCH.md "Overlay Styles" pattern with CRITICAL specifications:

```css
.overlay-container {
  position: fixed;        /* NOT absolute - fixed stays visible during scroll */
  top: 0;
  left: 0;
  width: 100vw;          /* Full viewport width */
  height: 100vh;         /* Full viewport height */
  z-index: 2147483647;   /* Maximum safe z-index value */
  background: #000;      /* Black background */
  display: flex;
  align-items: center;
  justify-content: center;
}

.placeholder-content {
  text-align: center;
}
```

**Why these CSS values (from RESEARCH.md):**
- position: fixed (not absolute) - stays in viewport during scroll
- z-index: 2147483647 - maximum safe integer, highest possible stacking order
- 100vw/100vh - covers entire viewport regardless of page size
- Injected into body via Shadow DOM - escapes page stacking contexts (Pitfall 2)

**Why event listener on window:**
- Ensures ESC captured even if focus moves to iframe or other element
- More reliable than listening on overlay div
- Standard pattern for modal/overlay escape handling

**Note on rem units:**
- Tailwind classes compile to rem by default
- PostCSS plugin (configured in plan 01) converts rem to px at build time
- This prevents Shadow DOM font-size inheritance issues (RESEARCH.md Pitfall 5)
  </action>
  <verify>
```bash
# Check files exist
ls entrypoints/content/ScreenSaverOverlay.tsx
ls entrypoints/content/style.css

# Build and check output
npm run build

# Verify ESC handler pattern
grep "key === 'Escape'" entrypoints/content/ScreenSaverOverlay.tsx
grep "runtime.sendMessage.*DEACTIVATE" entrypoints/content/ScreenSaverOverlay.tsx
grep "addEventListener.*keydown" entrypoints/content/ScreenSaverOverlay.tsx

# Verify overlay CSS
grep "position: fixed" entrypoints/content/style.css
grep "z-index: 2147483647" entrypoints/content/style.css
grep "100vh" entrypoints/content/style.css
```
  </verify>
  <done>
- entrypoints/content/ScreenSaverOverlay.tsx exists with default export
- useEffect registers keydown listener on window
- ESC key (e.key === 'Escape') sends DEACTIVATE message
- Event listener cleaned up on component unmount
- entrypoints/content/style.css exists with overlay styles
- Overlay uses position: fixed, z-index: 2147483647, 100vw/100vh
- Placeholder content shows "Screen Saver Active" and "Press ESC to exit"
- Build completes without errors
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. **File structure:**
   ```bash
   ls entrypoints/content/index.tsx
   ls entrypoints/content/ScreenSaverOverlay.tsx
   ls entrypoints/content/style.css
   ```

2. **Build verification:**
   ```bash
   npm run build
   # Should compile content script without errors
   ls .output/chrome-mv3/content-scripts/content.js
   ```

3. **Pattern verification:**
   ```bash
   # Shadow DOM setup
   grep "createShadowRootUi" entrypoints/content/index.tsx
   grep "cssInjectionMode: 'ui'" entrypoints/content/index.tsx

   # Message handling
   grep "runtime.onMessage" entrypoints/content/index.tsx
   grep "ui.mount" entrypoints/content/index.tsx

   # ESC handler
   grep "Escape" entrypoints/content/ScreenSaverOverlay.tsx

   # CSS positioning
   grep "position: fixed" entrypoints/content/style.css
   grep "z-index: 2147483647" entrypoints/content/style.css
   ```

4. **Type checking:**
   ```bash
   npm run type-check
   # Should pass with no errors
   ```
</verification>

<success_criteria>
1. Content script injects into all URLs (<all_urls> pattern)
2. Shadow DOM UI created with cssInjectionMode: 'ui' for style isolation
3. Message listener handles ACTIVATE (mounts UI) and DEACTIVATE (removes UI)
4. React root created/unmounted correctly via WXT lifecycle hooks
5. ScreenSaverOverlay component handles ESC key and sends DEACTIVATE message
6. Overlay styles use position: fixed, z-index: 2147483647, and viewport units
7. Build completes without errors, content script compiled successfully
8. No type errors in TypeScript compilation
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-&-activation/01-02-SUMMARY.md`

Include:
- What was built (content script + Shadow DOM overlay)
- How activation/deactivation flow works (background -> message -> content -> mount/remove)
- ESC key handling mechanism
- CSS isolation via Shadow DOM
- Files created
- Next plan dependency (plan 03 needs icon files and sound referenced by background.ts)
</output>
